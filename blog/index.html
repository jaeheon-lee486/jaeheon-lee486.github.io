<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> blog | JaeHeon Lee</title> <meta name="author" content="JaeHeon Lee"/> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🧠</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jaeheon-lee486.github.io/blog/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">JaeHeon&nbsp;</span>Lee</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/projects/">projects</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <div class="header-bar"> <h1>al-folio</h1> <h2>a simple whitespace theme for academics</h2> </div> <div class="tag-category-list"> <ul class="p-0 m-0"> <li> <i class="fas fa-hashtag fa-sm"></i> <a href="/blog/tag/formatting">formatting</a> </li> <p>&bull;</p> <li> <i class="fas fa-hashtag fa-sm"></i> <a href="/blog/tag/images">images</a> </li> <p>&bull;</p> <li> <i class="fas fa-hashtag fa-sm"></i> <a href="/blog/tag/links">links</a> </li> <p>&bull;</p> <li> <i class="fas fa-hashtag fa-sm"></i> <a href="/blog/tag/math">math</a> </li> <p>&bull;</p> <li> <i class="fas fa-hashtag fa-sm"></i> <a href="/blog/tag/code">code</a> </li> <p>&bull;</p> <li> <i class="fas fa-tag fa-sm"></i> <a href="/blog/category/blockquotes">blockquotes</a> </li> </ul> </div> <br> <div class="container featured-posts"> <div class="row row-cols-2"> <div class="card-item col"> <a href="/blog/2021/distill/"> <div class="card hoverable"> <div class="row g-0"> <div class="col-md-12"> <div class="card-body"> <div class="float-right"> <i class="fa-solid fa-thumbtack fa-xs"></i> </div> <h3 class="card-title text-lowercase">a distill-style blog post</h3> <p class="card-text">an example of a distill-style blog post and main elements</p> <p class="post-meta"> 8 min read &nbsp; &middot; &nbsp; <a href="/blog/2021"> <i class="fas fa-calendar fa-sm"></i> 2021 </a> </p> </div> </div> </div> </div> </a> </div> <div class="card-item col"> <a href="/blog/2015/code/"> <div class="card hoverable"> <div class="row g-0"> <div class="col-md-12"> <div class="card-body"> <div class="float-right"> <i class="fa-solid fa-thumbtack fa-xs"></i> </div> <h3 class="card-title text-lowercase">a post with code</h3> <p class="card-text">an example of a blog post with some code</p> <p class="post-meta"> 4 min read &nbsp; &middot; &nbsp; <a href="/blog/2015"> <i class="fas fa-calendar fa-sm"></i> 2015 </a> </p> </div> </div> </div> </div> </a> </div> </div> </div> <hr> <ul class="post-list"> <li><h3> <a class="post-title" href="https://velog.io/@jaeheon-lee/Paper-Review-Rethinking-Multiple-Instance-Learning-for-Whole-Slide-Image-Classification-A-Good-Instance-Classifier-is-All-You-Need" target="_blank">[Paper Review] Rethinking Multiple Instance Learning for Whole Slide Image Classification: A Good Instance Classifier is All You Need</a> <svg width="2rem" height="2rem" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p><h1 id="rethinking-multiple-instance-learning-for-whole-slide-image-classification-a-good-instance-classifier-is-all-you-need">Rethinking Multiple Instance Learning for Whole Slide Image Classification: A Good Instance Classifier is All You Need</h1> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/71dca4c3-a330-454a-9817-ba46f85c154e/image.png" alt=""></p> <p>contrastive learning 과 prototype learning, joint training strategy 를 사용하여 기존 MIL 의 문제점을 완화한 연구가 공개되었다. 최근에는 attention pooling 을 활용한 aggregation 기법들이 많이 사용되었는데, attention score 가 굉장히 일부 instance에 대해서만 높아 gradient가 제한적으로 흐르기 때문에 좀 더 괜찮은 instance classifier 를 만들어 mean pooling 하는 전략을 사용하였다.</p> <h2 id="introduction">Introduction</h2> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/825c4554-e20c-4879-bb6c-00e0871c4184/image.png" alt=""></p> <p>1) Low performance in instance-level classificaion : only the most easily identifiable positive instances are found while other more difficult ones are missed : instance pseudo labels contain a lot of noise 2) Bag-level classification performance is not robust : A typical example is the bias that occurs in classifying bags with a large number of difficult positive instances while very few easy positive instances</p> <p>The main contributions of this paper are as follows:</p> <ul> <li>We propose INS, an instance-based MIL framework that combines contrastive learning and prototype learning. This framework serves as an efficient instance classifier, capable of effectively addressing instance-level and bag-level classifi- cation tasks at the finest-grained instance level.</li> <li>We propose instance-level weakly supervised contrastive learning (IWSCL) for the first time in the MIL setting to learn good feature representations for each instance. We also propose the Prototype-based Pseudo Label Generation (PPLG) strategy, which generates high-quality pseudo labels for each instance through prototype learning. We further propose a joint training strategy for IWSCL, PPLG, and the instance classifier. </li> <li>We comprehensively evaluated the performance of INS on six tasks of four datasets. Extensive experiments and visualization results demonstrate that INS achieves the best performance of instance and bag classification.</li> </ul> <h2 id="related-work">Related work</h2> <h3 id="instance-based-mil-methods">Instance-based MIL Methods</h3> <ul> <li>주로 각 instance 에 pseudo label 을 붙이고 instance classifier 를 학습하고, bag 내부의 모든 instance prediction 을 aggregate하여 bag classification 을 수행한다.</li> <li>하지만 positive bag 의 상당 수의 negative instance 가 positive label 관련 noise 를 받게 된다.</li> </ul> <h3 id="bag-based-mil-methods">Bag-based MIL Methods</h3> <ul> <li>instance feature 를 추출하고 aggregate 하여 bag feature 로 bag classification 을 수행한다. 특히 attention-based method 가 main stream 이고, 독립된 scoring network 의 learnable attention weight 를 사용하여 각 instance feature 점수를 매긴다.</li> <li>하지만 쉬운 instance 에는 attention score 가 잘 반영되는데, difficult instance 에는 그렇지 않다.</li> </ul> <h3 id="prototype-learning-for-wsi-classification">Prototype Learning for WSI classification</h3> <ul> <li>derived from Nearest Mean Classifier, concise representation for instance</li> <li>(내게는) 친숙하지 않은 개념이라 레퍼된 논문을 좀 살펴봤다.</li> </ul> <p>TPMIL (TPMIL: Trainable Prototype Enhanced Multiple Instance Learning for Whole Slide Image Classification)</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/bb8bd6ee-72ef-4433-8078-fa4abc6b9b70/image.png" alt=""></p> <p>create learnable prototype vectors 후, attention score 로부터 얻은 soft pseudo label 과 KL divergence 를 계산하여 update 하는 프레임워크 이다.</p> <ul> <li>하지만 attention score 는 challenging positive instance 를 식별하지 못하는 문제점이 있다.</li> <li>이를 개선하기 위해, PPLG (prototype-based pseudo label generation) strategy 를 취해, high-quality pseudo-label 을 생성하고, instance contrastive representation learning, prototype learning, instance classifier 간의 joint training 을 수행한다.</li> <li>특히 negative bags 에서 sampling 한 instance 는 true negative instance 인 점을 활용하여 instance classifier 로부터 prototype learing 에 가이드를 준다.</li> </ul> <h2 id="methods">Methods</h2> <h3 id="problem-formulation">Problem Formulation</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/6b3c8fb4-948f-4dc7-bbd5-6c2aa0e3a222/image.png" alt=""></p> <p>binary setting 이다. 이 setting 에서는 negative bags 의 모든 instance 는 negative instance 이다. </p> <h3 id="framework-overview">Framework Overview</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/40981dd0-3afe-437a-a583-5f596987d2b3/image.png" alt=""></p> <p>bag 으로부터 instance $x_{i,j}$ 를 sampling 하고 query view 와 key view 를 two augmentation 으로부터 얻는다. query view branch 에서 encoder 를 거친 feature 를 instane classifier 와 projector (MLP-based) 에 넣고, 각각으로부터 predicted class ${\hat{y}<em>{i,j} \in R^2}$, feature embedding ${q</em>{i,j}\in R^d}$ 를 얻는다. key view branch 에는 gradient 가 흐르지 않는 대신, query branch 로부터 momentum update 방식으로 모델이 업데이트 된다. 그림처럼 encoder 와 projector 를 거쳐 ${k_{i,j}}$ 를 얻는다. 여기서 조금 복잡한데, 위 query branch 로부터 얻었던 predicted class ${\hat{y}<em>{i,j} \in R^2}$ 와 함께 넣어주는 것이 포인트이다. 이를 embedding queue 에 enqueue 한 후, 내부에서 contrastive learning loss 를 계산한다. 이 부분은 아래 다른 섹션에서 더 설명하도록 하겠다. 마지막으로, 다시 query branch 로부터 나온 ${\hat{y}</em>{i,j} \in R^2}$ 와, prototype vector와 loss 를 계산한다. PPLG module 내에서는 two representative feature vector 를 positive, negative class training 과정에서 계속해서 업데이트 한다. 이 또한 아래 섹션에서 더 설명하도록 하겠다.</p> <h3 id="instance-level-weakly-supervised-contrastive-learning">Instance-level Weakly Supervised Contrastive Learning</h3> <p>목적: 좋은 feature representation 을 얻는 것.</p> <p>논문에서도 언급하지만, 사실 contrastive learning 에서 가장 중요한 것은, 식이 어떻고를 떠나서 어떻게 negative, positive sample set 을 construction 하느냐가 핵심이다. 기존 self-supervised learning setting 에서는 본인과 본인을 제외한 나머지로 보통 셋을 구성했지만, MIL setting 에서는 negative bag in the training set 으로부터 뽑은 all instance 는 true negative label 을 갖고 같은 셋에 속하도록 할 수 있다. 이러한 트릭을 다른 어느 논문에서도 사용하지 않았다고 한다. 이 weak label 정보는 instance-level contrastive learning 을 효율적으로 guide할 수 있었다고 한다. </p> <p>특히 large Embedding Queue 에서 feature embedding $k_{i,j}$ 와 그것들의 class $\hat{y}_{i,j}$ 를 함께 저장했고, 이 때, true negative instance 같은 경우에는, predicted class 를 저장하지 않고, 바로 directly assign them a definite negative class 로 하였다. 이 부분을 계속 강조하는 이유는,, 나중에 framework 를 좀 더 자세히 봤을 때, &#39;임의로 만든 것&#39; 과 &#39;임의로 만든 것&#39; 간의 거리를 비교하고 또 &#39;임의로&#39; 만드는 과정이 들어가는데, 그것의 base... 기반이 되어주는 true basic label 으로써 굉장히 중요한 역할을 수행한다.</p> <ul> <li>Family and Non-family sample selection</li> </ul> <p>large embedding queue 에서 family set $F(q_{i,j})$ 와 non family set $F&#39;(q_{i,j})$ 를 구성하고, $q_{i,j}$ 에 기반하여 contrastive loss 를 계산한다. 이 때, $F(q_{i,j})$ 는 q, k 와 embedding queue whose class label equals $\hat{y}<em>{i,j}$ 로부터 구성되고, 그 나머지는 모두 $F&#39;(q</em>{i,j})$ 가 된다. 이것이 전부이다. <img src="https://velog.velcdn.com/images/jaeheon-lee/post/d17534eb-e4bd-4883-bef0-59e1a7738962/image.png" alt=""></p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/959709b9-49ed-4eca-9e1c-3721c2d3359b/image.png" alt=""></p> <p>B 는 minibatch 를 뜻한다. Q는 embedding queue 이다. 위 family set 과 non-family set 을 이용해 다음과 같은 loss 를 계산한다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/3dcdc6e4-8ec6-4be4-a084-a1d8aa215c32/image.png" alt=""></p> <ul> <li>Embedding Queue Updating</li> </ul> <p>iteration 끝마다, current instance&#39;s momentum embedding $k_{i,j}$ 와 predicted label 또는 true negative label 은 embedding queue Q 에 들어가고 오래된 건 dequeue 된다.</p> <h3 id="prototype-based-pseudo-label-generation">Prototype-based Pseudo Label Generation</h3> <p>목적: assign more accurate pseudo labels to instances by prototype learning</p> <p>아직 설명 전이지만, 이 과정을 통해, maintain two representative feature vector 를 얻는다. $\mu_r \in R^d$, $r=0,1$. 사실 pseudo label 의 생성과 prototype 의 updating process 역시 (아까 말했듯) true negative instance 와 instance classifier (predicted label을 만들어 주기 때문) 에 의해 guide 된다. </p> <p>만약 $x_{i,j}$ 가 positive bag 으로 부터 왔다면, embedding $q_{i,j}$ 과 prototype vectors $\mu_{r}$ 로 pseudo label $s_{i,j}\in R^2$ 를 생성한다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/ddf25a44-87be-45d5-be1f-5b3def66053a/image.png" alt=""></p> <p>동시에, prototype vector $\mu_{?}$ of the corresponding class 를 predicted label 과 embedding q 로 update 한다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/49c2743a-3c39-4044-b697-c98c97f8db7b/image.png" alt=""></p> <p>만약 negative bag 으로부터 왔다면, directly assign negative label 후, embedding q 를 활용하여 negative prototype vector 를 update 한다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/0ac4dcdc-fb4e-436a-a69f-2b25d96ff8b4/image.png" alt=""></p> <p>마지막으로, generated pseudo label 을 실제 encoder 로부터 나온 smoothed predicted value $p_{i,j} \in R^2$ 간의 cross-entropy loss 를 계산하여 iteration 을 마치게 된다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/c13cfd64-a742-4a94-92d3-aa95f9fa3df2/image.png" alt=""></p> <h3 id="bag-constraint-and-total-loss">Bag Constraint and Total Loss</h3> <p>정말 마지막 단계로, bag label 을 조금 더 활용하기 위해 embedding vector $q_{i,j}$ 를 mean pooling 해서 bag label 과 cross entropy loss 를 계산해서 total loss 에 더해준다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/ea76cea5-ede7-4e00-ae03-fb9360ad33a7/image.png" alt=""></p> <p>요즘 트렌드인 attention weight 를 전혀 사용하지 않은 부분이 상당히 인상적이다. </p> <h2 id="experimental-settings">Experimental Settings</h2> <h3 id="dataset">Dataset</h3> <ol> <li>Simulated CIFAR-MIL Dataset : 32x32 이미지 합쳐서 WSI 처럼 합성, 하나의 category label 을 positive 로 정의.</li> <li>Camelyon16 Public Dataset : 512x512 image patches under 10x mag, total 186604 instances.</li> <li>TCGA LUNG Cancer Dataset : 1054 WSIs, 5.2 million patches at 20x mag.</li> <li>Cervical Cancer Dataset : 374 WSIs, 5x mag, 224x224 patches</li> </ol> <h3 id="evaluation-metrics-and-comparision-methods">Evaluation Metrics and Comparision Methods</h3> <p>in both instance and bag classification, AUC &amp; acc are used. compared out INS to 11 competitors: MILRNN, Chi-MIL, DGMIL (instance) ABMIL, Loss-ABMIL, CLAM, DSMIL, TransMIL, DTFD-MIL, TPMIL, WENO (bag)</p> <h2 id="results">Results</h2> <h3 id="synthetic-dataset-cifar-mil">Synthetic Dataset CIFAR-MIL</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/ff074367-7960-42c8-bdb6-a0578a1cdf23/image.png" alt=""></p> <h3 id="camelyon-16-dataset">Camelyon 16 Dataset</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/11bdf6ef-5393-41b8-bb02-c629b5d5a4ed/image.png" alt=""></p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/8fbb55b8-9ea7-4acc-8d57-3faf8b98b179/image.png" alt=""></p> <h3 id="tcga-lung-cancer-dataset">TCGA-LUNG cancer Dataset</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/f9cb45e8-0b8b-4c92-9bcd-d43b097b8457/image.png" alt=""></p> <h3 id="cervical-cancer-dataset">Cervical Cancer Dataset</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/24f31a41-828e-4df8-aba5-5d9291c53906/image.png" alt=""></p> <h3 id="interpretability-study-of-the-lymph-node-metastasis">Interpretability Study of the Lymph Node Metastasis</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/9b947cb0-070d-4b2b-84ef-711d56835539/image.png" alt=""></p> <p>INS to predict the probability of each instance being positive within the positive bags and visuazualied the top 0.1% instances with the highest and lowest probilities separately.</p> <ul> <li>lymph node metastasis &quot;micropapillae&quot; are more prevalent</li> <li>특히, small clusters of infiltrating cancer cells forming hollow or mulberry-like nests without a central fibrovascular axis, surrounded by blank lacunae or lacunae between interstitial components</li> <li>negative lymph node more commonly exhibits a sheet-like pattern</li> </ul> <p>나머지가 조금 있긴 한데 추후에 업데이트 하겠다.</p> </p> <p class="post-meta"> 1 min read &nbsp; &middot; &nbsp; July 24, 2023 &nbsp; &middot; &nbsp; jaeheon-lee </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p></li> <li><h3> <a class="post-title" href="/blog/2023/post-bibliography/">a post with bibliography</a> </h3> <p>an example of a blog post with bibliography</p> <p class="post-meta"> 1 min read &nbsp; &middot; &nbsp; July 12, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> &nbsp; &middot; &nbsp; <a href="/blog/tag/formatting"> <i class="fas fa-hashtag fa-sm"></i> formatting</a> &nbsp; <a href="/blog/tag/bib"> <i class="fas fa-hashtag fa-sm"></i> bib</a> &nbsp; &nbsp; &middot; &nbsp; <a href="/blog/category/sample-posts"> <i class="fas fa-tag fa-sm"></i> sample-posts</a> &nbsp; </p></li> <li><h3> <a class="post-title" href="/blog/2023/jupyter-notebook/">a post with jupyter notebook</a> </h3> <p>an example of a blog post with jupyter notebook</p> <p class="post-meta"> 2 min read &nbsp; &middot; &nbsp; July 4, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> &nbsp; &middot; &nbsp; <a href="/blog/tag/formatting"> <i class="fas fa-hashtag fa-sm"></i> formatting</a> &nbsp; <a href="/blog/tag/jupyter"> <i class="fas fa-hashtag fa-sm"></i> jupyter</a> &nbsp; &nbsp; &middot; &nbsp; <a href="/blog/category/sample-posts"> <i class="fas fa-tag fa-sm"></i> sample-posts</a> &nbsp; </p></li> <li><h3> <a class="post-title" href="https://velog.io/@jaeheon-lee/Paper-Review-Self-Supervised-Learning-from-Images-with-a-Joint-Embedding-Predictive-Architecture" target="_blank">[Paper Review] Self-Supervised Learning from Images with a Joint-Embedding Predictive Architecture</a> <svg width="2rem" height="2rem" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p><h1 id="self-supervised-learning-from-images-with-a-joint-embedding-predictive-architecture">Self-Supervised Learning from Images with a Joint-Embedding Predictive Architecture</h1> <p>SNS 피드를 보다가 I-JEPA 관련 뉴스를 봤다. 제목 자체가 굉장히 intriguing 했는데 <a href="https://ai.facebook.com/blog/yann-lecun-ai-model-i-jepa/">https://ai.facebook.com/blog/yann-lecun-ai-model-i-jepa/</a> &#39;I-JEPA: The first AI model based on Yann LeCun&#39;s vision for more human-like AI&#39; 였다.. 게재된지는 꽤 되었지만 이번 CVPR 2023 발표와 함께 다시 한번 수면으로 올라왔다. paper 의 핵심 architecture 를 이해하면서 human-like AI 라는 term 에 대해 공감이 갔는데, 이유는 다음과 같다. 기존 generative approach for SSL 방식에서는 reconstruction 을 한 후에 loss 를 계산했는데, I-JEPA 에서는 representation space 에서 reconstruction (?) 및 loss 계산이 이루어진다. augmentation 이 따로 필요없다는 점도 포함될 수 있다. </p> <h2 id="introduction">Introduction</h2> <p>computer vision field 에서 two common families of approches for self-supervised learning 방식을 소개한다.</p> <ol> <li>Invariance-based pretraining methods (MoCo, SimSiam, VICReg, BarlowTwins...)</li> <li>Generative methods (MAE, language models)</li> </ol> <p>먼저 1번 방식의 문제점을 언급한다. pretraining methods can produce high semantic representations but introduce strong biases that may be detremental for certain downstream tasks. unclear how to generalize these biases for tasks requiring different levels of abstraction. (ex, segmentation &amp; classification do not require the same invariances.) (끄덕끄덕)</p> <p>또한 필자는 Cognitive learning 이론에서는 biological system 에서의 representation learning 의 핵심은 &quot;the adaptation of an internal model to predict sensory input responses&quot; 이다. 라고 하며 core of generative SSL model 의 핵심인 &quot;remove or corrupt portions of the input and learn to predict the corrupted content&quot; 와 같은 선상에 있다고 주장한다. </p> <p>이어서 이 방식의 문제점도 함께 언급한다. lower sementic level 의 representation 을 도출하고, 종종 underperform invariance-based pretraining inf off-the-shelf evaluation (ex linear probing) 하다고 지적한다.</p> <p>본 논문에서는 SSL representation 의 semantic level 을 prior knowledge (encoded through augmentatino) 없이 개선할 수 있는가에 대한 고민을 담고 있고, 이를 &quot;predict missing information in ab abstract representation space&quot; 하는 것으로 좋은 성능을 만들었다고 한다.</p> <p>다음은 introduction 맨 마지막에 있는 we demonstrate that ~ 이다.</p> <ul> <li>I-JEPA learns strong off-the-shelf representation without the use of hand-crafted view augmentations. </li> <li>I-JEPA outperforms pixel-reconstruction methods (like MAE) on ImageNet01K linear probing, etc</li> <li>I-JEPA 는 view-invariant pretraining model 과 semantic task 에서 competitive 했고, low-level vision task 를 outperform 함. (applicable to a wider set of tasks)</li> <li>I-JEPA is also scalable and efficient</li> </ul> <h2 id="background">Background</h2> <p>보통 background 는 간단히 하고 넘어가는데 읽는 것만으로 도움이 많이 되는 내용들이라 자세히 작성하려 한다.</p> <p>Self-supervised learning 은 &quot;inputs 들 간의 relationship 을 capture&quot; 하는 학습 방식이다. 이는 framework of Energy-Based Models (EBM) 으로 접근할 수 있다. incompatible input 에 대해서는 high energy를, compatible inputs 에 대해서는 low energy 를 할당하는 것이다. 현존하는 generative 및 non-generative model 에서는 아래 세가지 framework 로 설명할 수 있다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/25514140-d043-491e-abdc-edfbe6543fe0/image.png" alt=""></p> <h3 id="joint-embedding-architectures">Joint Embedding Architectures</h3> <p>JEA 는 비슷한 input 에 대해 비슷한 embedding, 다른 input 에 대해 서로 다른 embedding 을 만들도록 학습한다. Main Challenge with JEA 는 &quot;representaion collapse&quot; (aka dimensional collapse) 이다. energy landscape 가 flat 한 경우, 즉 encoder 가 trivial embedding 을 만드는 현상이다. 이러한 dimensional collapse 를 막기 위해 다음과 같은 loss 들이 연구되었었다. </p> <ul> <li>contrastive losses : push apart embeddings of negative examples</li> <li>non-contrastive losses : minimize informational redundancy</li> <li>clustering-based approches : maximize the entropy of the average embedding</li> </ul> <p>그림의 (a)에 해당하는 구조이다. representation space 에서 보통 loss가 계산된다. (전에도 리뷰한 적이 있는 내용인데) dimensional collapse 를 피하는 가장 핵심은 leverage an assymmetric architectural design between x-encoder and y-encoder 하는 것이었다.</p> <h3 id="generative-architectures">Generative Architectures</h3> <p>여태 리뷰했던 논문들은 대부분 JEA 였고 생성 기반 구조를 가진 논문은 MAE 정도만 읽어본 것 같다. (b) 내용인데, 이 구조는 additional variable z (cGAN (SSL은 아니지만) 에서의 condition에 해당할 수도 있고 MAE 의 mask 에 해당하는 부분 또는 position token 일 수도 있다) condition 위에서, directly reconstruct a signal y from a compatible signal x 이고, loss 는 reconstructed signal 과 원래 있던 기존 signal 사이에서 계산된다. </p> <h3 id="joint-embedding-predictive-architectures">Joint-Embedding Predictive Architectures</h3> <p>I-JEPA 에서 제안하는 구조이다. (c) 내용이고, (b) 구조와 상당히 닮아 있으면서, loss function is applied in embedding space (not input space) 라는 점이 key difference 이다. 또한 hand-crafted augmentation 을 없애는 대신, representation 상에서의 &quot;mask&quot;, 즉 additional information &quot;z&quot; 를 달리하여 condition된 representation 을 predict 한다. 물론 representation space 상에서의 작업이기 때문에 dimensional collapse 를 염두에 두고 asymmetric architecture 를 설정하는 것도 중요함을 강조했다.</p> <h2 id="method">Method</h2> <p>now describe the proposed Image-based Joint-Embedding Predictive Architecture (I-JEPA) <img src="https://velog.velcdn.com/images/jaeheon-lee/post/95b31d60-6ce4-428a-a71e-7bb3279bf935/image.png" alt=""></p> <p>context-encoder 와 target-encoder, 그리고 predictor (가 아직 뭔지 모르지만) 에서 ViT architecture 를 사용했다. 아래 두 줄로 Overall objective 를 설명할 수 있다.</p> <ul> <li>given a context block</li> <li>predict the representations of various target blocks (in the same image)</li> </ul> <p>뭔가 MAE 와 비슷해보인다. 그럼 context block 과 target block 은 뭘까 라는 질문이 든다. 그 전에 target 이 뭔지부터 규명한다.</p> <h3 id="targets">Targets</h3> <p>how we produce the targets? 우선 y 라는 image 를, N non-overlapping patches 를 생성한다. 이후 이를 target-encoder $f_{\hat{\theta}}$ 에 집어넣고, patch-level representation $s_y$ = {$s_{y_1},,, s_{y_N}$} 을 얻는다. 그리고 여기서 loss 에 사용할 M 개의 block 을 뽑는데, 1 개의 block 마다 여러개의 patch 가 들어있고 이는 overlap 이 가능하다. 이 block 을 지칭하는 &quot;mask&quot; 하나를 $B_i$ 라고 부르고, 그에 해당하는 i번째 block 의 patch set 을 $s_y(i) = {S_{y_j}}_{j\in B{i}}$ 라고 부른다. 보통 M 은 4고 aspect ratio 는 (아마 너비&amp;높이) (0.75, 1.5) 이고, random scale (아마 크기) 는 (0.15,0.2) 이다. 저자는 &quot;target block&quot; 은 masking the &quot;output of the target-encoder&quot; 이지 not &quot;input&quot; 이라고 강조한다. 즉 input 에 바로 mask 씌우는 것이 아니라 embedding 된 것에 씌우는 것이라고 강조한다.</p> <h3 id="contexts">Contexts</h3> <p>Recall, the goal behind I-JEPA is to predict the target block representations from <strong>single context block</strong>. image 에서 random scale (0.85, 1.0) 으로 그리고 unit aspect ratio 로 a single block x 를 뽑고 이 mask 를 $B_x$ 라고 부른다. target block 과 context block 모두 random 하게 뽑았으니 당연히 겹칠 수 있다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/f332368a-426f-4750-a3a2-e824c690cdca/image.png" alt=""></p> <p>위 그림은 target block 과 context block 의 예시이다. 마찬가지로 context block 역시 context encoder $f_\theta$ 에 넣어 $s_x = {S_{x_j}}_{j\in B{x}}$ 를 만든다. 위의 target encoder 와는 독립된 네트워크이다. </p> <h3 id="prediction">Prediction</h3> <p>이제 $s_x$도 뽑았고 M개의 target block 에 해당하는 patch representation set인 $s_y(1), ... , s_y(M)$ 도 뽑았다. 이 때, 주어진 각 $s_y(i)$에 대해, predictor $g_\phi(-,-)$ 는 context encoder 의 output 인 $s_x$ 와 mask token for each patch ${m_j}_{j\in B_i}$ 를 받아서 $\hat{s}_y(i)$ 를 만든다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/572c6b6a-acf3-4cfe-8168-80e1ab3d8e66/image.png" alt=""></p> <p>mask token is parameterized by a shared learnable vector with an added positional embedding. 즉, mask 는 constant 가 아니라 parameter 이다. 처음에는 이 부분이 굉장히 헷갈렸다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/01b2f476-44f0-4d2c-bd95-8b53248ae139/image.png" alt=""></p> <p>위 그림을 보면, context block 과 target block 이 전혀 겹치지 않고 있는데 어떻게 masking 을 한다는거지? 라는 의문이 들어 헷갈렸다. 하지만 물리적인 masking 을 의미하는 것이 아니라, 하나의 parameter z 즉 condition (너는 이 부분을 예측해야 해 라는 정보) 로 받아 들이고 나니 이해가 수월했다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/424905bd-4266-4a18-963a-5232ddb0fb17/image.png" alt=""></p> <p>그냥 concat이다. context block patch representation 과 mask token, positional encoding 을 concat, add 해서 predictor network 에 통과시키고, 이를 target block patch representation 과 비교하는 것이다.</p> <h3 id="loss">Loss</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/86de9a88-6f55-4539-a3af-3a036d483119/image.png" alt=""> L2 loss 를 사용했다.</p> <h2 id="image-classification">Image Classification</h2> <p> I-JEPA 가 좋은 high-level representation 을 augmentation 없이도 잘 학습한다는 것을 보이기 위해, linear probing 과 partial fine-tuning protocol 을 통한 image classificaion task 를 수행하였다. ImageNet-1K dataset 으로부터 pretrained 된 다른 self-supervised model 을 비교군으로 사용했고, 모든 I-JEPA 모델은 resolution 224 x 224 pixels 로 train 되었다.</p> <h3 id="imagenet-1k">ImageNet-1K</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/222db1f4-476d-4667-9ca6-b36c6f3f774c/image.png" alt=""></p> <p>Table1. 은 common ImageNet-1K linear-evaluation benchmark 에 따른 성능 기록이다. SSL 사전학습 후 frozen 된 후 linear classifier 가 학습되었다. data augmentation 없는 MAE와 CAE (context autoencoder), data2vec 이 비교 실험 모델로 사용되었다. augmentation 이 없었음에도 불구하고 invariant approach (like iBOT) 과 competitive 한 성능을 보여주었다.</p> <h3 id="low-shot-imagenet-1k">Low-shot ImageNet-1K</h3> <p> <img src="https://velog.velcdn.com/images/jaeheon-lee/post/23929fd2-4171-4ff9-b317-7b614a348777/image.png" alt=""></p> <p>Table2 는 1% ImageNet benchmark performance 이다. 1%의 available ImageNet label 을 사용하였다. I-JEPA 는 MAE 보다 less pretraining epoch 을 사용하여 outperform 하였고, data2vec 보다 더 작은 네트워크를 사용하여 비슷한 성능을 내었다. input resolution 을 높여 (to 448) 학습했을 때 이전 data augmentation 을 사용했어야만 했던 invariance approach SSL 방식들의 결과를 모두 뛰어넘었다. 흠..</p> <h3 id="transfer-learning">Transfer learning</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/f9e5a5dd-bbb9-4eca-8d2b-1ea49b71d37d/image.png" alt=""></p> <h2 id="local-prediction-tasks">Local Prediction Tasks</h2> <p>위에선 classification task 에 대해 확인했는데, 기존 generative 성능을 뛰어넘을 뿐만 아니라 high semantic task 에 특화된 invariance based method 에도 competitive 한 성능을 기록했다. 이제 local image features 도 잘 학습하는지를 알아보았다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/45dfe475-4d2e-40ef-bd59-eb3431c98068/image.png" alt=""></p> <p>object counting과 depth prediction 에서 view-invariance based method 를 outperform 했다. </p> <h2 id="scalability">Scalability</h2> <h3 id="model-efficiency">Model Efficiency</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/074e1927-a415-4951-9dcb-491c94b44f71/image.png" alt=""></p> <p>I-JEPA 는 기존 방법보다 highly scalable 함을 보이고 있다. 이전 방식들보다 더 적은 시간으로 더 높은 성능을 기록하고 있다. (task: semi-supervised evaluation on 1% ImageNet-1K) </p> <h3 id="scaling-data-size--model-size">Scaling data size &amp; model size</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/c673d1fb-bb91-4355-a34c-41a720b8ba27/image.png" alt=""></p> <p>I-JEPA 는 larger dataset 에서 pretraining 될수록 benefit 이 있다는 것을 확인했고, larger model size 로부터 학습했을 때 더 높은 성능을 기록함을 확인하였다. (scalability)</p> <h2 id="predictor-visualization">Predictor Visualization</h2> <p>I-JEPA에서 predictor의 역할은, predictor에 context encoder 의 output 과 함께, positional mask token 을 통과시켰을 때 target block representation 을 예측하도록 하는 것이다. 이것이 representation space level 에서 이루어지기 때문에 이를 visualization 해보았다. 캬</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/04c3323e-7092-4b63-a91b-7cd4775aba25/image.png" alt=""> </p> <p>너무 멋지다 방법은 RCDM framework 에 따라 decoder 를 학습했다고 하는데, 정확히 이해는 못했다. (논문 reference 를 참고하도록 하자)</p> <h2 id="ablations">Ablations</h2> <h3 id="predicting-in-representation-space">Predicting in representation space</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/d79b4685-ec7d-454a-ac0b-d15e1e2ceaea/image.png" alt=""></p> <p>I-JEPA 의 핵심 중 하나는 representation space 에서 loss 를 계산한다는 것이다. 이것이 효용이 있는지 확인하기 위해 pixel-space 와 representation-space 에서 loss 계산해서 성능을 비교하였다. </p> <h3 id="masking-strategy">Masking strategy</h3> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/06ea2b2e-4c17-45b7-bb89-8203e7a21a1c/image.png" alt=""></p> <p>mask 방식을 달리하여 실험을 여럿 돌렸다.</p> <h2 id="conclusion">Conclusion</h2> <p>재밌구만..</p> </p> <p class="post-meta"> 1 min read &nbsp; &middot; &nbsp; June 21, 2023 &nbsp; &middot; &nbsp; jaeheon-lee </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p></li> <li><h3> <a class="post-title" href="https://velog.io/@jaeheon-lee/Paper-Review-RetCCL-Clustering-guided-contrastive-learning-for-whole-slide-image-retrieval" target="_blank">[Paper Review] RetCCL: Clustering-guided contrastive learning for whole-slide image retrieval</a> <svg width="2rem" height="2rem" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </h3> <p><h1 id="retccl-clustering-guided-contrastive-learning-for-whole-slide-image-retrieval">RetCCL: Clustering-guided contrastive learning for whole-slide image retrieval</h1> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/844b3d38-4281-4d55-a435-b351f64821cc/image.png" alt=""></p> <p>디지털 병리 AI 심포지움에서 reference 되었던 breast npj 2023 논문에서 차용한 SSL 방법이다. WSI 에서 SSL 방식을 도입할 때 발생할 수 있는 문제점을 인지하고 이를 해결하기 위해 fancy 한 방법을 사용했다. 결과 좋은 성능을 내었고 많은 논문에서 인용되고 있어 의미 있는 논문이라 생각한다.</p> <h2 id="introduction">Introduction</h2> <ul> <li>WSI annotation 및 computation cost 높음.</li> <li>SSL 방식을 사용하면 이 문제를 alleviate 할 수 있음.</li> <li>기존 SimCLR 등의 방식에서 patch 를 instance 로 여겨 학습하면, serious bias 생김.</li> <li>unbalanced tissue type distribution 와 large portion of similar tissues</li> <li>이를 위해 다음 두가지 방법을 사용한 framework 를 제안함. 1) clustering-guided contrastive learning (CCL) for feature extraction 2) distinctive query patch selection, ranking for searched pathes, and aggregation algorithm for interpretable WSI searching</li> </ul> <h2 id="related-works">Related works</h2> <h3 id="self-supervised-representation-learning">Self-supervised representation learning</h3> <ul> <li>natural image application to the histopathology domain : domain shift</li> <li>focus on semantic features within the specific task : limited model generalization</li> <li>not tested on large and diverse histopathological image datasets</li> </ul> <h3 id="histopathological-image-retrieval">Histopathological image retrieval</h3> <ul> <li>traditional hand-craft features</li> <li>DL method based high-level features</li> <li>suboptimal performance due to the domain shift btw natural and histopathological images</li> </ul> <h2 id="methods">Methods</h2> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/15bf65b7-5608-429c-b489-3482bc2ff118/image.png" alt=""></p> <p>다음과 같은 구조로 되어있다.</p> <ol> <li>weighted InfoNCE, group-level InfoNCE 활용한 feature extraction</li> <li>1) offline database construction for WSI retrieval</li> <li>2) online WSI query process</li> </ol> <h3 id="contrastive-learning-based-feature-extractor">Contrastive learning based feature extractor</h3> <h4 id="preliminary-of-contrastive-learning">Preliminary of contrastive learning</h4> <p>x: image, x_q, x_k: augmented views 라 할 때, contrastive learning 은 q &amp; k+ sample 을 가까이에, q &amp; k- sample 을 멀리 두도록 학습한다. 가장 기본적인 loss 는 다음과 같이 쓸 수 있다. <img src="https://velog.velcdn.com/images/jaeheon-lee/post/a3f4b1cf-e2af-474b-963d-610d0c43c6c3/image.png" alt=""></p> <p>sigma L 이 포함된 묶음은 memory bank 내 negative samples 을 의미한다. 이를 통해 momentum encoder 이 moving average 방식으로 update 된다.</p> <h4 id="proposed-clustering-guided-contrastive-learning">proposed clustering-guided contrastive learning</h4> <p>위와 같은 방식을 사용했을 때 다른 데이터셋에선 잘 나올지 몰라도 WSI 데이터에는 맞지 않을 수 있다. 위 식으로 봤을 때, negative sample memory bank에 positive sample 로 consider 되어야 할 highly correlated sample 이 포함되어 있을 가능성이 높다. 또, different patch 들이 같은 tissue 로부터 샘플링 되었고 strikingly similar appearance 를 가졌다면 문제는 더 심각해진다. 이는 histopathology 분야에서 SSL 방식을 도입할 때 줄곧 언급되어 왔던 한계점이기도 하다.</p> <p>이 문제를 해결하기 위해, 두가지 loss (weighted InfoNCE &amp; group-level InfoNCE) 로 구성된 clustering-based contrastive learning method 를 제안한다. W-InfoNCE loss 는 possible false-negative sample 의 영향을 줄이기 위함이고, G-InfoNCE loss 는 distinctive group center 끼리는 멀도록 하고 다른 instance 는 group 으로 모으는 역할을 한다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/844b3d38-4281-4d55-a435-b351f64821cc/image.png" alt=""></p> <p>먼저 three augmented images 를 얻는다. (xp, xk, xq) 그리고 두개의 encoder h (xp, xq) 와 f (xk) 를 통과시켜 feature (hp, fk, hq) 를 얻는다. 이후 two MLP heads g1, g2 를 이용해, hp 를 gp1, gp2 로 encoding 하고, hq 를 hq1, hq2 로 encoding 한다. fk 의 경우 g2 를 이용해 gk 를 얻는다. MLP head g2 를 통과시켜 나온 세 개의 feature gp2, gq2, gk 를 이용해 weighted InfoNCE loss 를 계산하게 되고, MLP head g1 을 통과시켜 나온 두 개의 feature gp1, gq1 은 cluster 하는 데에 사용되어 향후 group-level infoNCE loss 에 활용된다. 이후 final loss function 은 두 loss 의 조합으로 계산된다.</p> <h4 id="online-clustering-guided-memory-bank-construction">Online clustering-guided memory bank construction</h4> <p>weight 를 주어 false-negative-like sample 의 영향을 줄임으로써 기존 memory bank 와는 차별된 online clustering-guided memory bank 를 제안한다.</p> <p>매 training epoch 마다, two positive pairs {gp2, gk}, {gq2, gk} 를 활용해, shared memory bank 로 contrastive learning 을 수행한다. 우선 negative sample 을 k-means clusering 을 활용해 Q classes 로 나누고, 이를 Q sub-memory queues 로 본다. 이 때, 각 centroid c (q개) 와 gk 간의 similarity 를 계산하고, 이 similarity 값 중 가장 큰 값을 갖는 Q 를 Q_max 라고 지정한다. 이후 negative sample 과의 similarity 를 계산할 때 다음 $\phi (g_k-)$ 을 씌워서 영향력을 조절한다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/ad090da4-8b36-4d95-85e8-eb8b43cdd43a/image.png" alt=""></p> <p>즉 가장 가까운 Q cluster 에 해당하는 negative sample, 즉 false-negative-like sample 의 영향력을 줄이는 것이다. 다음과 같은 식으로 weighted infoNCE loss 를 표현한다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/4ab0665e-df97-46e3-87f7-b17c1d54a031/image.png" alt=""></p> <h4 id="group-level-discrimination">Group-level discrimination</h4> <p>이 식은 2021 CVPR 에 올라왔던 cross-level discrimination (CLD) loss function 으로부터 따왔다. 여기에 auxiliary branch 를 붙여 unbalanced positive/negative sample ratio 를 해소하려 하였다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/844b3d38-4281-4d55-a435-b351f64821cc/image.png" alt=""></p> <p>다시 위 그림에서, 이번엔 g1 MLP head 를 보자. hp 와 hq 는 다시 g1 을 거쳐 gp1, gp2 vector 를 생성한다. mini-batch 내에 있는 embedding 들은 각 두 branch 에서 S개의 cluster 로 clustering 되고, 각각의 cluster centroid 도 할당한다. 이때 요 cluster centroid 를 이용해서 다시 positive negative sample 을 branch 에서 정의하고 group-level InfoNCE loss 를 계산하게 된다. 구체적으로, g__p__1 (p branch이다) 이 있을 때, 이것의 positive sample 은 S개의 cluster 중 가장 가까운 1개의 cluster centroid ($S^{q+}$, q branch 임) 의 sample 이 되는 것이고, 나머지 S-1 cluster 는 negative sample 이 된다. 식은 다음과 같다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/ffbd62fb-16c7-452a-8aca-03cf5a6704c5/image.png" alt=""></p> <p>Group-level infoNCE loss 와 위에서 계산했던 weighted InfoNCE loss 의 combination 으로 final loss 를 꼐산하고 update 한다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/96ffeeee-4f92-45bd-bf75-19b07bcc5da7/image.png" alt=""></p> <h3 id="wsi-retrieval-method">WSI retrieval method</h3> <h4 id="preliminary-of-wsi-retrieval">Preliminary of WSI retrieval</h4> <p>WSI retrieval의 background 를 알려주고 있긴 한데 우선 나는 WSI retrieval 이 무엇인지도 잘 몰랐다. retrieval은 대략 &quot;검색&quot; 이라는 뜻을 가지고 있는데, 다른 reference 논문을 타고 들어가보니, 다음과 같은 작업을 가리키는 것 같았다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/0494bd6e-856c-41f8-a16d-49af3961d668/image.png" alt=""></p> <p>결국 feature extraction 을 잘 수행하고, similarity 계산을 잘 수행해서 WSI 내에서 빠르게 잘 찾아내는 것이 task 의 핵심이라고 생각하면 될 것 같다. 두가지 방식을 소개하고 있다. </p> <ul> <li>Yottixel method (Y)</li> <li>FISH</li> </ul> <p>공통적으로 두 방식은 WSI 를 patch 로 나누고 clustering 을 한 후 query 에서 patch-by-patch matching 후 database 에서 가장 비슷한 patch 를 선정한다고 한다. 이 때 Y 는 pretrained DenseNet 으로 feature를 뽑고, 이를 binary code 로 compression 하는 반면, FISH 는 VQ-VAE pretrained on TCGA 로 generate texture feature 한다. 또한 Y 는 false match 를 줄이기 위해 Hamming distance 를 계산하고, FISH 는 Van Emde Boas tree with an uncertainty-based ranking algorithm 을 사용한다고 한다.</p> <h4 id="proposed-wsi-retrieval-method">Proposed WSI retrieval method</h4> <p>overall procedure 는 다음과 같다. 크게 offline database construction, online WSI query process 두가지로 나뉜다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/7ada49e8-5f46-46e8-b6e9-5b683506ee86/image.png" alt=""></p> <h4 id="database-construction-for-wsi-retrieval">Database Construction for WSI Retrieval</h4> <p>offline database construction 에서 먼저 patchify 하고 CCL-based feature extractor 를 거쳐 나온 feature 로 mosaic generation 을 하는데, mosaic generation 은 dual clustering 으로 이루어져 있다. 먼저 CCL-feature-based K-means clustering 을 수행하고, 그 coordinate 를 받아 spatial-coordinate-based clustering algorithm 을 수행한다. 그 결과 distinctive patches (called a mosaic) 이 생성되고 full WSI 를 대표하게 되는 것이다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/730be0ef-a675-4d6a-b2ee-75a975a8f0b5/image.png" alt=""></p> <p>역시 말보단 알고리즘이지. FeatureKMeans 함수로 K1 개의 cluster 로 나눈 뒤, 이를 SpatialKMeans 를 거쳐 다시 각 cluster 를 4-5개의 cluster 로 나눈다. 즉, 4-5개 * K1 개의 cluster centroid 가 생기고 이것이 distinctive patch 가 되는 것이다. </p> <h4 id="wsi-query-process">WSI Query Process</h4> <p>WSI database construction 이 완료되고, online 으로 patch-level retrieval 을 시작한다. nearest neighbor searching method 를 사용하고, 이 retrieved patch 와 meta-information 으로 ranking and aggregation algorithm 을 활용해 가장 비슷한 WSI 를 찾아준다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/e0a9cd48-1639-4c0e-b0e4-a671c699743a/image.png" alt=""></p> <p>이 부분도 알고리즘으로 보는게 이해가 잘된다. WSI image query 를 받으면, 각 patch k 개에 대해 feature vector 를 얻고, 이에 대한 retrieval bag 을 k개 얻는다. bag 1개 당 t 개의 retrieved patch 가 있는데 bag 마다 다르다고 한다. bag 1개의 retrieved patch 와 WSI 의 patch 사이의 cosine similarity d 를 구하고, 이 d 와 diagnosis 정보를 활용하여 probability pm 을 계산한다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/783a7b23-8571-4c3d-aec2-d732f4789b7c/image.png" alt=""></p> <p>이 pm 은 결국 요약해서 말하면, bag 안에서 m번째 diagnosis type 의 확률이다. yj 는 database 로부터 나온 diagnosis information (bag 의 정보) 이다. $\delta()$ 는 두 개의 input 이 같으면 1 을 뱉고 다르면 0을 뱉는 일종의 indicator function 이다. $w_{y_j}$ 는 occurrence frequency (normalized probability) 인데, 이것도 역시 jth diagnosis type 이 얼마나 database 에 있는지를 나타낸다. $(d^j +1)/2$ 는 [-1,1] 인 cosine similarity 의 range 를 [0,1] 로 transform 해준 것이다. 간단히 생각해서 $w_{y_j}(d^j +1)/2$ 자체를 j 번째 sample 에 대한 score 라고 치환해서 생각하면 된다. 그럼 식 자체는 전체 score 의 합 중에서, m 번째 diagnosis subtype 에 포함된 score 의 합이 되어 m 번째 diagnosis type 의 확률로 여길 수 있다. </p> <p>이 pm 을 이용해서 entropy 를 각 bag 에 대해서 계산하고, ranking 즉 reorder 한다. 이후 procedure REMOVE BAGS WITH LOW QUALITY 에서, AveTop function 을 이용해서 criterion $\eta$ 를 구하는데, AveTop function 은 각 bag 마다 상위 5개의 cosine similarity 를 평균 낸 것이다. 이 criterion 을 넘지 못하는 bag 들은 remove 한다. 이 bag 내부에서 top 5개의 patch 를 고르는 것으로 마무리가 된다. </p> <h2 id="experimental-results-and-discusions">Experimental results and discusions</h2> <h3 id="datasets">Datasets</h3> <ul> <li>TCGA</li> <li>PAIP</li> <li>UniToPatho</li> <li>TissueNet</li> <li>DiagSet-A.2.</li> </ul> <h3 id="experimental-metric">Experimental metric</h3> <p>다음 두가지 (많이 쓰인다고 하는) Acc@k (top-k accuracy) and mMV@k(majority vote at the top k search results) 를 썼다.</p> <ul> <li>Acc@k: retrieved similar image 가 query image와 correct label 이면 높게 측정</li> <li>mMV@k: more strict metric, majority 가 query image 와 correct label 이어야 높게 측정</li> </ul> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/819d0682-b40a-4a07-a9a6-569f7408fb84/image.png" alt=""></p> <h3 id="results-of-patch-level-retrieval">Results of patch-level retrieval</h3> <h4 id="effect-of-network-components">Effect of network components</h4> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/b98e5516-2a70-49f5-8e06-cd6047a9b167/image.png" alt=""></p> <p>key innovation 인 clustering-based memory bank construction (Mem) 을 추가했을 때와 group-level InfoNCE (Gro) 를 추가했을 때 baseline 보다 성능이 향상되었고 같이 혼합해서 사용했을 때 가장 높았다. </p> <p>이외에도 다양한 hyperparameter 및 setting 에 대한 abltation study 를 진행했고, 논문에 자세히 언급되어 있다.</p> <h4 id="comparison-between-our-ccl-and-other-ssl-based-feature-extractors">Comparison between our CCL and other SSL-based feature extractors</h4> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/75c28ab2-5186-41de-b1e6-90132ecaaa99/image.png" alt=""></p> <p>SimCLR v1, SwAV, Moco v2 과 CCL-based feature extractor 의 retrieval 성능을 비교했다. 성능면에서 측정한 모든 metric 에 대해 가장 좋은 성능을 보여줬고, 특히 가장 strict 한 metric 인 mMV 에서의 성능 향상이 컸다. </p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/e58dc0a2-9b0a-4a79-abfc-99dcd2f7093e/image.png" alt=""></p> <p>UniToPatho (normal, hyperplastic polyp, tubular adenoma, tubulo-villous adenoma) 에서 각 subtype 을 nice 하게 잘 찾은 것을 볼 수 있다. 또한 TissueNet의 결과를 봤을 때, texture 와 color 가 많이 다름에도 잘 찾은 것을 볼 수 있다. 그 아래 failed case 가 소개 되어 있는데, 저자는 실패했음에도 morphological feature 가 pathologists 간의 disconcordance 를 야기할 정도로 굉장히 비슷했다고 주장한다. </p> <h3 id="results-of-wsi-retrieval">Results of WSI retrieval</h3> <p>1) searching for anatomic sites 2) searching for cancer subtypes based on the same human site</p> <h4 id="results-of-anatomic-site-retrieval">Results of anatomic site retrieval</h4> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/888d2459-ab82-4406-a423-b856d35f3520/image.png" alt=""></p> <p>앞선 Yottixel 과 FISH 에서 사용했던 frozen and FFPE WSIs in TCGA 를 사용해서 성능 측정이 이루어졌다. 당연하게도 database 는 모든게 포함된 database 가 아니라 TCGA 3만장 (FFPE 11791, frozen 15237) 이 포함된 database 에서 진행했다고 한다. 결과 20% 넘는 성능향상까지 보여주었다.</p> <h4 id="results-of-cancer-subtype-retrieval">Results of cancer subtype retrieval</h4> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/2c5efbfe-e6e7-41cf-9cb1-388c0d435c29/image.png" alt=""></p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/9e58c2f9-8926-4a95-83b6-7ee3397342ab/image.png" alt=""></p> <p>각 frozen 과 FFPE WSI 에 대해서 +10% than Yottixel and +3% than FIST in FFPE, +40% improvement on specific subtype such as MESO 등 큰 성능 향상을 보였다.</p> <h4 id="interpretability-analysis">Interpretability analysis</h4> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/fdac3fd9-b09c-4668-9b3a-cd97c84734fe/image.png" alt=""></p> <h3 id="results-of-downstream-classification-task">Results of downstream classification task</h3> <p>제안한 SSL pre-trained feature extractor 가 다른 downstream task 에서도 유용하게 사용될 수 있음을 보였다.</p> <p><img src="https://velog.velcdn.com/images/jaeheon-lee/post/6a239abf-7f35-4c5c-989a-c7ad34032635/image.png" alt=""></p> <p>DiagSet-A.2 dataset 에서 four-class classification task 를 진행했고 그 결과를 나타내었다. highest 를 보였던 SwAV 보다도 성능이 높게 측정되었고, 20% 데이터를 training 에 사용했을 때 ImageNet 이 100% 를 사용했을 때 (supervised learning setting) 보다 성능이 높게 측정되어, SSL 방식의 효용성을 보였다. </p> <h2 id="conclusion">Conclusion</h2> <p>WSI-level, patch-level 에서 사용가능한 histopathological image retrieval algorithm 을 제안했고, visually interpretable result 를 보여주었다. CCL-based backbone model 을 새로 고안했으며, database construction 후 ranking, curation, and aggregation 이 포함된 retrieval algorithm 을 사용했다. 이는 current WSI retrieval method에서 보여주는 성능을 큰 폭으로 뛰어넘었고 feature 는 다른 downstream task 에서 사용될 수 있을만큼의 potential 을 보여주었다. </p> <p>와 진짜 실험하느라 힘들었겠다</p> </p> <p class="post-meta"> 1 min read &nbsp; &middot; &nbsp; May 19, 2023 &nbsp; &middot; &nbsp; jaeheon-lee </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p></li> </ul> <nav aria-label="Blog page naviation"> <ul class="pagination pagination-lg justify-content-center"> <li class="page-item disabled"> <a class="page-link" href="" tabindex="-1" aria-disabled="">Newer</a> </li><li class="page-item active"><a class="page-link" href="/blog/index.html" title="blog">1</a></li> <li class="page-item "><a class="page-link" href="/blog/page/2/index.html" title="blog - page 2">2</a></li> <li class="page-item "><a class="page-link" href="/blog/page/3/index.html" title="blog - page 3">3</a></li> <li class="page-item "><a class="page-link" href="/blog/page/4/index.html" title="blog - page 4">4</a></li> <li class="page-item "><a class="page-link" href="/blog/page/5/index.html" title="blog - page 5">5</a></li> <li class="page-item "> <a class="page-link" href="/blog/page/2/">Older</a> </li> </ul> </nav> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> &copy; Copyright 2023 JaeHeon Lee. Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>